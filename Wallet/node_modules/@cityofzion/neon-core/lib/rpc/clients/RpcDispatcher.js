import logger from "../../logging";
import { fetch } from "cross-fetch";
import { AbortController } from "abort-controller";
const log = logger("rpc");
/**
 * Low level method to directly send a json-rpc request.
 * @param url - address to send request to
 * @param query - json-rpc request body
 * @param config - rpc configuration
 * @returns a json-rpc response
 */
export async function sendQuery(url, query, config = {}) {
    log.info(`RPC: ${url} executing Query[${query.method}]`);
    const fetchConfig = _createFetchReq(query.export(), config);
    const response = await fetch(url, fetchConfig);
    if (response.ok) {
        return response.json();
    }
    throw new Error(`Encountered HTTP code ${response.status} while executing Query[${query.method}]`);
}
/**
 * Low level method to directly send a list of json-rpc requests.
 * Note that the responses will not be typed.
 * @param url - address to send request to
 * @param batch - array
 * @param config - rpc configuration
 * @returns a list of untyped json-rpc responses
 */
export async function sendQueryList(url, batch, config = {}) {
    const fetchConfig = _createFetchReq(batch.map((q) => q.export()), config);
    const response = await fetch(url, fetchConfig);
    if (response.ok) {
        return response.json();
    }
    throw new Error(`Encountered HTTP code ${response.status} while executing Query[${batch
        .map((q) => q.method)
        .join(",")}]`);
}
function _createFetchReq(body, config) {
    const fetchConfig = {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
    };
    if (config.timeout) {
        const timeoutController = new AbortController();
        setTimeout(() => timeoutController.abort(), config.timeout);
        fetchConfig.signal = timeoutController.signal;
    }
    return fetchConfig;
}
/**
 * Basic JSON-RPC 2.0 Dispatcher. Contains the basic infrastructure to send out JSON-RPC 2.0 methods.
 * Client interfaces should accept this RpcDispatcher as a constructor parameter.
 *
 * @example
 *
 * ```ts
 * const dispatcher = new RpcDispatcher("http://www.example.com");
 * const result = await dispatcher.execute(new Query({"method": "listplugins"}));
 * ```
 */
export class RpcDispatcher {
    constructor(url) {
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            throw new Error("Please provide an url that starts with http:// or https://");
        }
        this.url = url;
    }
    /**
     * Takes an Query object and executes it. Throws if error is encountered.
     */
    async execute(query, config) {
        const rpcResponse = await sendQuery(this.url, query, config !== null && config !== void 0 ? config : {});
        if (rpcResponse.error) {
            throw new RpcError(rpcResponse.error);
        }
        return rpcResponse.result;
    }
    async executeAll(batchQuery, config) {
        const responses = await sendQueryList(this.url, Array.isArray(batchQuery) ? batchQuery : batchQuery.queries, config !== null && config !== void 0 ? config : {});
        if (responses.some((r) => r.error)) {
            const allErrs = {};
            responses.forEach((r, idx) => {
                if (r.error) {
                    allErrs[`query[${idx}]`] = r.error;
                }
            });
            throw new RpcError({ code: -1, message: JSON.stringify(allErrs) });
        }
        return responses.map((r) => r.result);
    }
}
export class RpcError extends Error {
    constructor(errResponse) {
        super(errResponse.message);
        this.code = errResponse.code;
    }
}
//# sourceMappingURL=RpcDispatcher.js.map